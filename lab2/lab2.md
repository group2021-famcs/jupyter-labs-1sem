# Лабораторная работа №2. Циклы, массивы

**Внимание**: Запрещено использование функций/методов стандартной библиотеки (`pow`, `count`, `reverse`, ...)!

Во всех задачах целые числа помещаются в тип `int`.

#### Настройка проекта

1. Разархивируйте архив с шаблонным проектом лабораторной в любое удобное для вас место.
2. Откройте разархивированный проект в CLion (File -> Open, выберите папку проекта)
3. В нижней части экрана откройте вкладку `CMake` и нажмите на значок `"Reload CMake project"`
   ![png](lab2_files/reload_cmake_project.png)
4. Скопируйте изображения `einstein.jpg` и `house.jpg` из папки `lab2_files` в папку `cmake-build-debug`

#### Где писать код ?

В этой лабораторной для вас уже созданы шаблоны файлов для решения каждого задания.
Например, для решения первого задания про сумму цифр следует открыть файл `z1_1_digit_sum.cpp`, написать код и запустить программу, предварительно выбрав `digit_sum` в качестве текущего (активного) запускаемого файла.

![png](lab2_files/choose_task.png)

## Задание 1. Циклы for, while

### 1.1 Сумма цифр
Вводится натуральное число `n`. Посчитайте сумму его цифр.

*Input*:
```
42187
```
*Output:*
```
22
```

### 1.2 Наибольший общий делитель

Вводится два числа. Найдите их НОД с помощью алгоритма Евклида.

*Input*:
```
8 12
```
*Output:*
```
4
```

### 1.3 Количество различных элементов

Вводится массив из <img src="https://render.githubusercontent.com/render/math?math=N"/> целых чисел. Причём гарантируется, что <img src="https://render.githubusercontent.com/render/math?math=a_0 \leqslant a_1 \leqslant \ldots \leqslant a_{n-1}"/>. Найдите количество различных чисел в этом массиве.

*Input*:
```
6
1 1 2 2 2 100
```
*Output:*
```
3
```

### 1.4 Переворот массива

Дан массив целых чисел. Расположите его элементы в обратном порядке.\
Запрещается создавать дополнительные массивы или вводить/выводить элементы не по порядку.

*Input*:
```
6
1 3 5 7 9 11
```
*Output:*
```
11 9 7 5 3 1
```

### 1.5 Перемножение матриц

Даны две целочисленные матрицы. Найдите их [произведение](https://ru.wikipedia.org/wiki/Умножение_матриц).

*Input*:
```
2 4
1 2 3 4
5 6 7 8
4 3
1 2 3
4 5 6
7 8 9
10 11 12
```
*Output:*
```
2 3
70 80 90
158 184 210
```

## Задание 2. Работа с картинками

Любое чёрно-белое изображение может быть представлено как двумерная матрица чисел от 0 до 255 (~~50~~ 256 оттенков серого), где 0 обозначает чёрный цвет, а 255 — белый.

Для начала, чтобы познакомиться со вспомогательными функциями, загрузим из файла две картинки одинакового размера, сохраним в файл и посмотрим на них, чтобы убедиться в корректности чтения/записи.

Сперва подключим библиотеку:
```c++
#include "lab_helpers.h"
```
и добавим следующий код в `int main()`:
```c++
const std::vector<std::vector<int>> im1 = LoadGrayscaleImage("einstein.jpg");
const std::vector<std::vector<int>> im2 = LoadGrayscaleImage("house.jpg");

assert(im1.size() == im2.size()); // Heights of images should match
assert(im1.front().size() == im2.front().size()) // Widths of images should match
const int n = im1.size();
const int m = im1.front().size();
std::cout << "Height: " << n << "\nWidth: " << m << "\n";
WriteGrayscaleImage(im1, "einstein_copy.jpg");
WriteGrayscaleImage(im2, "house_copy.jpg");
```

Проверьте, что исходные изображения `einstein.jpg` и `house.jpg` лежат в папке `cmake-build-debug` вашего CLion-проекта.

Запустите программу. Убедитесь, что рядом с исходными картинками появились их копии. Откройте их и визуально убедитесь, что получившаяся картинка соответствует исходной.

![png](lab2_files/lab2_17_0.png)

![png](lab2_files/lab2_18_0.png)

### 2.1 Смешивание

> В этом и всех последующих заданиях вместе с кодом приложите к решению получившиеся картинки, назвав их по шаблону `<task>_<subtask>_any_title_you_wish.jpg`
> Например, `2_1_blended.jpg`, `2_2_horizontal.jpg`

> **Внимание:** В этом и всех последующих заданиях вы **должны** использовать любые две собственные картинки в формате .jpg, при условии что они одинакового размера.
>
> *Совет*: Не берите картинки в сверх-высоком разрешении, ограничьтесь 1024 в качестве максимального размера по ширине и/или высоте. В противном случае будьте терпеливы, т.к. ваш код будет работать ощутимое число времени.

> ***Рекомендуется*** все пункты задания 2 выполнять в одном файле, разделяя пункты соответствующим комментарием - в таком случае вам будет удобнее отправлять решение, а нам проверять.

Создайте новую матрицу, в которой цвет каждого пикселя получен смешиванием цветов соответствующих пикселей первого и второго изображения с коэффициентом <img src="https://render.githubusercontent.com/render/math?math=\alpha"/>. При <img src="https://render.githubusercontent.com/render/math?math=\alpha = 0"/> результат должен совпадать с первым изображением, а при <img src="https://render.githubusercontent.com/render/math?math=\alpha = 1"/> — со вторым.

Для <img src="https://render.githubusercontent.com/render/math?math=\alpha = 0.6"/> результат должен выглядеть так:

![png](lab2_files/lab2_20_0.png)

### 2.2 Конкатенация

Создайте новую матрицу, полученную вертикальной конкатенацией двух предыдущих, то есть "дописыванием" набора строк второй матрицы к набору строк первой.
    
![png](lab2_files/lab2_22_0.png)

Создайте новую матрицу, полученную горизонтальной конкатенацией двух предыдущих, то есть "дописыванием" строк второй матрицы к соответствующим строкам первой.
    
![png](lab2_files/lab2_24_0.png)

### 2.3 Отражение

Создайте новую матрицу, полученную горизонтальным отражением первой.

![png](lab2_files/lab2_26_0.png)

### \*2.4 Поворот

Создайте новую матрицу, полученную поворотом первой на 90 градусов направо.\
_Подсказка_: разложите операцию поворота на две более простые операции.
    
![png](lab2_files/lab2_28_0.png)

### 2.5 Обработка изображения

> В этом задании также нужно приложить свои ответы на поставленные вопросы

Создайте новую матрицу на основе `einstein.jpg`, где каждый элемент равен среднему арифметическому девяти чисел: его собственного значения в исходной картинке и его восьми соседей (также из исходной картинки).

Можете ли вы визуально заметить разницу между новым и исходным изображениями ?

Повторите этот процесс несколько раз, (например, 3, 5, 10 раз). Стала ли заметна разница между изображениями ?
Как в фотографии называется реализованная вами операция ?
> В ответ приложите картинку, полученную пятикратным повторением операции.

Какое получится изображение, если повторить операцию достаточно большое кол-во раз (например, 1000) для данной картинки ? Почему ?

Ответьте на эти же два вопроса для вашей собственной картинки.
> Попробуйте сперва подумать, ответить на эти вопросы, а затем проверить свои выводы экспериментально. 

> В ответ также приложите картинку, полученную двухсоткратным повторением операции для вашей собственной картинки.

## Задание 3. Генерация фрактала

В этом задании вам предстоит сгенерировать фрагмент [Множества Мандельброта](https://ru.wikipedia.org/wiki/Множество_Мандельброта).

Для любой точки вещественной плоскости <img src="https://render.githubusercontent.com/render/math?math=(x, y)"/> её принадлежность множеству определяется следующим образом.
- Возьмём два числа: <img src="https://render.githubusercontent.com/render/math?math=a_0 = 0"/> и <img src="https://render.githubusercontent.com/render/math?math=b_0 = 0"/>
- На каждой итерации будем преобразовывать их по правилу:\
  <img src="https://render.githubusercontent.com/render/math?math=a_{i%2B1} = a_i^2 - b_i^2 + x"/>\
  <img src="https://render.githubusercontent.com/render/math?math=b_{i%2B1} = 2 a_i b_i + y"/>\
  (откуда берутся такие формулы, вы поймёте, когда пройдёте комплексные числа).
- Если полученная последовательность ограничена (то есть существует такое <img src="https://render.githubusercontent.com/render/math?math=R"/>, что <img src="https://render.githubusercontent.com/render/math?math=\forall n : a_n^2 + b_n^2 < R^2"/>), то точка <img src="https://render.githubusercontent.com/render/math?math=(x, y)"/> принадлежит множеству, а иначе не принадлежит.

Так как проверить ограниченность последовательности в общем виде — нетривиальная задача, мы ограничимся приближённым вычислением. Можно показать, что как только расстояние от <img src="https://render.githubusercontent.com/render/math?math=(a_n, b_n)"/> до <img src="https://render.githubusercontent.com/render/math?math=(0, 0)"/> станет больше <img src="https://render.githubusercontent.com/render/math?math=2"/>, последующие расстояния будут возрастать. Поэтому можно проделывать некоторое заранее заданное количество итераций (например, <img src="https://render.githubusercontent.com/render/math?math=14"/>), и если точка <img src="https://render.githubusercontent.com/render/math?math=(a_{14}, b_{14})"/> всё ещё осталась в круге радиуса <img src="https://render.githubusercontent.com/render/math?math=2"/>, то считать, что <img src="https://render.githubusercontent.com/render/math?math=(x, y)"/> принадлежит множеству.

Вам нужно выбрать прямоугольник на плоскости и сгенерировать описанный фрактал. Пусть чёрным цветом обозначается принадлежность точки множеству, а белым — не принадлежность.
    
![png](lab2_files/lab2_30_0.png)

### \*Градиент

Можете также исследовать, как генерируются градиентные изображения этого множества. На самом деле нужно всего лишь использовать количество произведённых итераций до выхода из круга для определения цвета пикселя.
    
![png](lab2_files/lab2_32_0.png)